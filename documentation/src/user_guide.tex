\documentclass[a4paper,oneside]{memoir}
\usepackage{listings}%
\usepackage{xcolor}
\usepackage{hyperref}
\lstset{%
    backgroundcolor=\color{yellow!20},%
    basicstyle=\small\ttfamily,%
    numbers=none, numberstyle=\tiny, stepnumber=2, numbersep=5pt,%
    }%

\lstset{emph={%  
    PARAM%
    },emphstyle={\color{blue}\bfseries},%
    morekeywords={filename},
    keywordstyle={\color{red}\ttfamily}
}%

\usepackage{fourier} % or what ever
\usepackage[scaled=.92]{helvet}%. Sans serif - Helvetica
\usepackage{color,calc}
\newsavebox{\ChpNumBox}
\definecolor{ChapBlue}{rgb}{0.00,0.65,0.65}
\makeatletter
\newcommand*{\thickhrulefill}{%
  \leavevmode\leaders\hrule height 1\p@ \hfill \kern \z@}
\newcommand*\BuildChpNum[2]{%
  \begin{tabular}[t]{@{}c@{}}
    \makebox[0pt][c]{#1\strut}  \\[.5ex]
    \colorbox{ChapBlue}{%
      \rule[-10em]{0pt}{0pt}%
      \rule{1ex}{0pt}\color{black}#2\strut
      \rule{1ex}{0pt}}%
  \end{tabular}}
\makechapterstyle{BlueBox}{%
  \renewcommand{\chapnamefont}{\large\scshape}
  \renewcommand{\chapnumfont}{\Huge\bfseries}
  \renewcommand{\chaptitlefont}{\raggedright\Huge\bfseries}
  \setlength{\beforechapskip}{0pt}
  \setlength{\midchapskip}{26pt}
  \setlength{\afterchapskip}{40pt}
  \renewcommand{\printchaptername}{}
  \renewcommand{\chapternamenum}{}
  \renewcommand{\printchapternum}{%
    \sbox{\ChpNumBox}{%
      \BuildChpNum{\chapnamefont\@chapapp}%
      {\chapnumfont\thechapter}}}
  \renewcommand{\printchapternonum}{%
    \sbox{\ChpNumBox}{%
      \BuildChpNum{\chapnamefont\vphantom{\@chapapp}}%
      {\chapnumfont\hphantom{\thechapter}}}}
  \renewcommand{\afterchapternum}{}
  \renewcommand{\printchaptertitle}[1]{%
    \usebox{\ChpNumBox}\hfill
    \parbox[t]{\hsize-\wd\ChpNumBox-1em}{%
      \vspace{\midchapskip}%
      \thickhrulefill\par
      \chaptitlefont ##1\par}}%
}
\chapterstyle{BlueBox}

\setlength\afterchapskip {\onelineskip }
\setlength\beforechapskip {\onelineskip }

%\setlength{\oddsidemargin}{0.03\paperwidth} 
%\setlength{\evensidemargin}{0.03\paperwidth}
%\setlength{\textwidth}{0.7\paperwidth}
%\setlength{\voffset}{0pt}

%\usepackage{anysize}
%\marginsize{2.25cm}{2cm}{}{1,25 cm}
\setlrmarginsandblock{3cm}{2.5cm}{*}
\setulmarginsandblock{2.5cm}{2.5cm}{*}
\checkandfixthelayout

\usepackage{graphicx}
\usepackage{float}
\graphicspath{{./img/}}
\DeclareGraphicsExtensions{.pdf,.jpeg,.png}


\begin{document}

\let\clearforchapter\par % cheating, but saves some space
\chapter{The TLUT tool flow: An introduction}

The TLUT tool flow is a tool flow that generates FPGA configurations. Its biggest difference with the traditional FPGA flow is the use of a new technology mapper, the TLUT mapper. The TLUT tool flow was developed to implement Dynamic Circuit Specialization (DCS) on FPGAs. A DCS implementation of an application specializes its circuit for the current values of a number of specific inputs, called parameters. This specialized circuit is smaller, and in some cases faster, than the original circuit. However, it is only correct for one set of parameter values. Each time the parameters change value, a new specialized circuit is generated. This new specialized circuit is then loaded into the FPGA using partial run-time reconfiguration.\\

The TLUT tool flow offers an efficient implementation of DCS because it uses the concept of parameterized configurations. A parameterized configuration is a configuration in which some bits are expressed as Boolean functions of the parameters. Before the FPGA can be configured, the parameter values are used to evaluate the Boolean functions. This generates the specialized configuration. Several papers on the academic underpinnings of the TLUT tool flow are listed in the wiki of this project or are contained in the documentation directory. There you can also find more information on our current research on extending and improving the TLUT tool flow. The TLUT tool flow itself and how to use it, is described in much more detail in this user guide.

\section{What can I do with this tool flow?}
First, you can evaluate our adapted TLUT technology mapper. 
This  allows you to compare its results with a conventional technology mapper and see for yourself if Dynamic Circuit Specialization can be used to optimize your application. 
We have included a framework to make this comparison very easy. 
The following pages provide clear examples and show how to adapt the framework for you own uses.

Second, our tool flow has been integrated with the Xilinx FPGA tool flow so that you can perform DCS on a commercial Virtex 2 Pro  or Virtex 5 FPGA.
A number of examples that you can run right away on either the XUPV2P board (Virtex 2 Pro) or ML507 board (Virtex 5) are included in this repository. 
Information on creating your own project is also included in this document.
The tool flow may be extended in the future to support more FPGAs, such as the Virtex 6 and 7.

\section{Contact us}
The TLUT tool flow is released by Ghent University, ELIS department, Hardware and Embedded Systems (HES) group (\href{http://hes.elis.ugent.be}{\emph{http://hes.elis.ugent.be}}).

If you encounter bugs, want to use the TLUT tool flow but need support or want to tell us about your results, feel free to contact us.
We can be reached at \href{mailto:hes@elis.ugent.be}{\emph{hes@elis.ugent.be}}.

\section{Referencing the TLUT tool flow}
If you use the TLUT tool flow in your work, please reference in your publications the following paper:

\emph{Karel Bruneel, Wim Heirman, and Dirk Stroobandt. 2011. ``Dynamic Data Folding with Parameterizable FPGA Configurations.'' ACM Transactions on Design Automation of Electronic Systems 16 (4).}

You may also refer to one of our others papers if you think it is more related.

\section{Contents of this document}
Chapter~\ref{sec:setup}: \emph{Setup}: The setup manual\\
Chapter~\ref{sec:standalone_flow}: \emph{Standalone TLUT tool flow}: The manual for running your own experiments without implementation on an FPGA\\
Chapter~\ref{sec:xilinx_flow}: \emph{Xilinx-integrated TLUT tool flow}: The manual for creating your own DCS project using the Xilinx XUPV2P board\\
Chapter~\ref{sec:contents}: \emph{Contents}: Description of the contents of this package\\

\clearpage
\chapter{Setup}\label{sec:setup}
\begin{lstlisting}
> make
\end{lstlisting}
This downloads and builds the dependencies listed below, builds the TLUT technology mapper and creates a `source' file which sets environment variables. 
Make sure you agree with the respective licences of the dependencies before running make. 

Set your environment variables using:
\begin{lstlisting}
> . source
\end{lstlisting}

Section~\ref{sec:tlut_testing} explains how to test the TLUT tool flow, while in Section~\ref{sec:xilinx_testing} you can find information on how to test the integration with the Xilinx tool flow and the XUPV2P or ML507 board.

\section{Dependencies}
\begin{itemize}
\item Dependencies to be provided by the user:
\begin{itemize}
\item A UNIX operating system (tools used: gcc (tested with v4.1.2), bash, minicom, curl, stty, \dots)
\item The readlink library
\item Quartus II (tested with Web Edition version 11.0 SP1, version 11.0 SP2 or later will not work out of the box), Altera Corporation, \url{http://www.altera.com}
%Test succeeded: 10.0 Full Version (kheyse pixie), 12.1 SP0 Full Version (maxeler)
%Test succeeded but results differ:  8 Full Version (Tom)
%Test partially succeeded: 11.0 SP1 Web edition (kheyse, Ubuntu Virtualbox)
\item Java (tested with version 1.6.0 and 1.7), Oracle, \url{http://www.java.com}
\item Python 2.7, \url{http://www.python.org}
\end{itemize}
\item Optional dependencies to be provided by the user:
\begin{itemize}
\item A Xilinx XUP Virtex-II Pro Development System (XUPV2P board) and Xilinx Design Suite 9 (tested with version 9.1 SP2), Xilinx Inc., \url{http://www.xilinx.com}\\ % and partially tested with version 9.2
Version 9 is old, but newer versions don't work well with the Virtex-II Pro.
\item A Xilinx ML507 Virtex-5 Development System and Xilinx Design Suite (tested with version 13.4), Xilinx Inc.
\item A Digilent Genesys Virtex-5 Development System and Xilinx Design Suite (tested with version 13.4), Digilent Inc.
\end{itemize}
\item Dependencies automatically downloaded and installed:
\begin{itemize}
\item Aiger 1.9.4, JKU Institute for Formal Models and Verification, \url{http://fmv.jku.at/aiger}
\item ABC (version 810ba683c042, 5 October 2012), Berkeley Logic Synthesis and Verification Group, \url{http://www.eecs.berkeley.edu/\~alanmi/abc}
\item RapidSmith 0.5.1, BYU RapidSmith Projec,  \url{http://rapidsmith.sourceforge.net}\\
And the dependencies of Rapidsmith itself, such as Hessian 4.0.6.
\end{itemize}
\end{itemize}

\clearpage
\chapter{Standalone TLUT tool flow}\label{sec:standalone_flow}
The standalone TLUT tool flow can be used to evaluate the impact of DCS on your design. This tool flow will map your annotated VHDL or Verilog design and tell how much smaller or faster (LUT depth) your design can become when using parameterized configurations.

A number of examples are included in the `examples' directory that you can run using the included Python scripts.
E.g.
\begin{lstlisting}
> cd examples/treeMult4b
> ./treeMult4b.py
\end{lstlisting}

\section{Testing}\label{sec:tlut_testing}
Your installation of the TLUT tool flow can be tested using the script in the directory `tests'.
\begin{lstlisting}
> cd tests
> ./examples_test.sh
\end{lstlisting}
If you encounter errors, troubleshooting information can be found in Section~\ref{sec:tlut_troubleshooting}.


\section{Creating your own project: A step-by-step approach}\label{sec:step_by_step}
Below, we have provided a step-by-step approach to set up your own Python script starting from the \emph{treeMult4b} example:
\begin{enumerate}
\item Make a folder for your design and copy the treeMult4b folder from the examples directory. You need at least the files \emph{abc.rc} and \emph{treeMult4b.py}
\begin{lstlisting}
> mkdir yourDesign
> cp -r examples/treeMult4b/* yourDesign/
\end{lstlisting}
\item Replace treeMult4.vhd by copying your VHDL/Verilog files, describing your design, into the \emph{yourDesign}-folder
\begin{lstlisting}
> rm treeMult4b.vhd
\end{lstlisting}
\item Annotate the parameters in your top level VHDL/Verilog file.

Any input signal, or combination of input signals, of your top level module can be chosen as parameter. Preferably the designer will choose the slowly changing input signals as parameters, because a change in the value of the parameters results in a reconfiguration of the FPGA. Different combinations can be tested easily by changing the annotations. In the following example a simple multiplexer is described in VHDL and the `sel' input signal is annotated as a parameter.
\lstset{language=VHDL}
\begin{lstlisting}
entity multiplexer is
port(
  --PARAM
  sel : in  std_logic_vector(1 downto 0);
  --PARAM
  in  : in  std_logic_vector(3 downto 0);
  out : out std_logic
);
end multiplexer;

architecture behavior of multiplexer is
begin
  out <= in(conv_integer(sel));
end behavior;
\end{lstlisting}
The Verilog annotations are quite similar. The following Verilog example, a simple multiplier, can be found in the examples folder;
\lstset{language=Verilog}
\begin{lstlisting}
module mult(x,y,z);
parameter N = 16;
input [N-1:0] x;
//PARAM
input [N-1:0] y;
//PARAM
output [2*N-1:0]z;
assign z = x * y;
endmodule
\end{lstlisting}
 
\item Modify the Python script
\begin{lstlisting}
> mv treeMult4b.py yourDesign.py
> nano yourDesign.py
\end{lstlisting}
Edit the 6th line, in which the \emph{run} function is called, according to the documentation in Section~\ref{sec:run_function}. The most important change you have to make is filling in the name of the VHDL file of your design.

\item Run the modified Python script
\begin{lstlisting}
> ./yourDesign.py
\end{lstlisting}
\item \label{sec:check_par}Check the `.par' file in the work directory, to ensure the parameters were correctly recognised. It should list all the signal names of the parameters, i.e. one for each line of a bus signal. 
The tool for extracting parameters from VHDL and Verilog is still limited and can not yet parse all VHDL/Verilog constructs.
\item Analyze the results. As an example, the output of the Python script of the treeMult4b project is given;

\begin{lstlisting}
Stage: TLUT mapper
Luts (TLUTs)     depth     check
12 (12)          1         PASSED    
Stage: SimpleMAP
Luts             depth     check     
67               10        PASSED    
Stage: ABC fpga
Luts             depth     check     
67               10        PASSED 
\end{lstlisting}

The first column shows the number of LUTs in each mapping solution. These can be compared directly and represents the number of K-LUTs needed to implement the design. In this case, the TLUT mapper needs 12 LUTs, and SimpleMAP and ABC's fpga need 67.

SimpleMAP and ABC fpga both perform mapping for a conventional, not parameterised, configuration. The same results could be expected for both tools because they implement basically the same algorithm. However, ABC fpga contains some optimisations, such as `area recovery', which haven't been (completely) implemented in SimpleMAP. While the number of LUTs may differ between the two tools, you can expect the depth to be always equal.

The number between brackets `()' is only relevant for the TLUT mapper. It shows the number of LUTs that will actually be reconfigured at run-time. We call these LUTs TLUTs. In this case all 12 of the LUTs are TLUTs and will be reconfigured at run-time.

The third column shows the depth of each mapping solution. This is the number of LUTs in the longest path, a measure for the speed of the circuit. 

Finally, column 4 shows if the mapping solution has passed the equivalence test. This check is performed to see if the resulting circuit still has the same functionality as the original input.

% Hier de verschillen tussen simpleMap en abc bespreken of later pas in hoofdstuk 4?

\end{enumerate}


\section{The $run$ function}\label{sec:run_function}
To test the TLUT mapper on your own design (described in VHDL or Verilog), import the \emph{run} function from \emph{fast\_tlutmap} in your own Python script and call it with the following arguments:
\begin{lstlisting}
run(module, submodules, K, virtexFamily, performCheck, 
	verboseFlag, generateImplementationFilesFlag)
\end{lstlisting}
\begin{itemize}
\item \textbf{module} - String\\
The location of the top level of your design. If your design consists of only one VHDL/Verilog module, then you only have to pass the location of this module as the first argument and you can ignore the second argument.

E.g. run('yourDesign.vhd')

\item \textbf{submodules} - list of Strings - \textit{optional}\\
If your design consists of a top level module and several submodules, you can add a list of submodules here, for example if you have one top level module and two submodules.

E.g. run('yourTopLevelModule.vhd', ['yourFirstSubModule.vhd', 'yourSecondSubModule.vhd'])

\item \textbf{K} - integer - \textit{default 4}\\
You can choose the number of inputs a LookUp Table has on your target FPGA

E.g. run('yourDesign.vhd', 6)
or run('yourDesign.vhd', K=6)

\item \textbf{performCheck} - boolean - \textit{default True}\\
When checks are turned on, the resulting mapping is verified using a miter and satisfiability solver. This ensures that the mapped circuit implements the same functionality as the input circuit.

E.g. run('yourDesign.vhd', performCheck=False)

\item \textbf{verboseFlag} - boolean - \textit{default False}\\
This activates the verbose mode in which more information gets printed regarding the execution of the flow.

E.g. run('yourDesign.vhd', verboseFlag=True)

\item \textbf{virtexFamily} - String - \textit{default undefined}\\
Set the Virtex family to ``virtex2pro" or ``virtex5". This sets ``K" for you and is a required argument in combination with ``generateImplementationFilesFlag=True''. This option is only used when implementing DCS on a real FPGA.

\item \textbf{generateImplementationFilesFlag} - boolean - \textit{default False}\\
Generate VHDL files for implementation of DCS on a real FPGA. This option requires ``virtexFamily'' to be set.
\end{itemize}


\section{Advanced}
It is also possible to start from an `.aag' or `.blif' file. As a reference for this we provide examples \emph{AES} and \emph{tripleDES}. 
Advanced experiments can be set up by copying \emph{fast\_tlutmap} and using this file as a template for your experiment.

\section{Troubleshooting}\label{sec:tlut_troubleshooting}
Try running one of the examples in the `examples' folder to verify that your environment is set up correctly.\\

These are a few common errors and their solution:
\begin{itemize}
\item \emph{Throws ``Python ImportError: No module named fast\_tlutmap'' (or others):}\\
The environment variables probably aren't set up correctly. Try running `. source' in the main directory. 
If you have moved the main directory, the paths in the `source' file are no longer correct. Update it using `make source' and do `. source' again.

\item \emph{Throws ``java.lang.OutOfMemoryError'':}\\
The Java technology mappers don't have enough memory available. Try to use the \emph{setMaxMemory} function. It can be imported from the \emph{fast\_tlutmap} Python script and should be called before the \emph{run} function. This function sets the maximum memory usage for the Java tools in megabytes.
\lstset{language=python}
\begin{lstlisting}
from fast_tlutmap import run, setMaxMemory

setMaxMemory(4096)
run('treeMult4b.vhd', K=4, performCheck=True, verboseFlag=False)
\end{lstlisting}

\item \emph{The number of TLUTs is 0, or the reduction in number of LUTs is lower than expected:}\\
Check if all parameters were correctly extracted from your VHDL/Verilog. See Section~\ref{sec:step_by_step}, step~\ref{sec:check_par}.
\end{itemize}


\clearpage
\chapter{Xilinx-integrated TLUT tool flow}\label{sec:xilinx_flow}

The Xilinx-integrated TLUT tool flow has been verified and tested on the following boards, it supports both MicroBlaze and PowerPC implementations.
\begin{itemize}
	\item \textbf{XUPV2P}: Contains a Virtex 2 pro(XC2VP20) with a PowerPC 405 processor.
	\item \textbf{ML507}: Contains a Virtex 5(XC5VFX70T) with a PowerPC 440 processor.
	\item \textbf{Genesys - Digilent}: Contains a Virtex 5(XC5VLX50T) that has no on-board CPU.
        \item \textbf{XUPV5}: Contains a Virtex 5(XC5VLX110T) that has no on-board CPU.
\end{itemize}

Example projects for each of the boards are included in the 'examples' directory. For each of these boards at least the XOR-example was implemented. This example implements a XOR port that is turned on and off through run-time reconfiguration. The XUPV2P examples are implemented using Version 9 of the Xilinx tools. The ML507-board has two examples, a PowerPC and a MicroBlaze-based implementation. The Genesys and XUPV5 boards only have a MicroBlaze implementation, as they don't have hardware CPU. For the Virtex 5 boards, version 13.4 of the Xilinx was used.

\begin{itemize}
\item[XUPV2P :]
\item `examples/xorExample/xps'
\item `examples/xorExample/xps\_mi'
\item `examples/treeMult4b/xps'
\item[ML507 :]
\item `examples/xorExample/xpsV13'
\item `examples/xorExample/xpsV13\_blaze'
\item `examples/treeMult4b/xpsV13'
\item[Genesys :]
\item `examples/xorExample/xpsV13\_blaze\_genesys'
\item[XUPV5 :]
\item `examples/xorExample/xpsV13\_XUPV5110T'
\end{itemize}

\section{Testing}\label{sec:xilinx_testing}
This section explains how to run all these examples in order to test your setup.

First, connect your board to the computer using a USB cable (for bitstream configuration) and a serial cable (for debugging).
Then, open each of the projects (see above) in XPS (using the version 9 for the XUPV2P and version 13.4 for the ML507, Genesys and XUPV5 board) and choose ``Generate bitstream''. You may immediately terminate this process or it may produce an error but this is OK, this creates a number of files for the project so that the automated test scripts can run.

%For the ML507 examples you also have to open Xilinx SDK, choose ``File'', ``Import'', ``General'', ``Existing Projects into Workspace'' and choose %the ``workspace'' subdirectory of the example. Choose not to copy the projects. Afterwards you can close SDK.

Now you can run all tests on these projects by doing:
\begin{lstlisting}
> cd tests
> ./virtex2pro_test.sh
or
> ./virtex5_test.sh
or
> ./virtex5_blaze_genesys_test.sh
or
> ./virtex5_blaze_test.sh
or
> .virtex5_VLX110T_test.sh
\end{lstlisting}

Every project is now being built, loaded onto the FPGA and DCS is tested using the embedded PowerPC or a MicroBlaze(you can find the debug output from the FPGA in the `received.txt' file in the project directory). This will take a long time. Make sure minicom is not running at the same time, because this will make it impossible to read the debug output from the FPGA. If everything works fine you will get the following result. 

%powerpc-eabi-ar: creating ../../../lib/libxil.a
%powerpc-eabi-ar: creating ../../../lib/libxil.a
%./virtex2pro_test.sh: line 4:  6732 Terminated cat ...
\begin{lstlisting}
Testing xorExample/xps
...
xorExample/xps succeeded
Testing xorExample/xps_mi
...
xorExample/xps_mi succeeded
Testing treeMult4b/xps
...
treeMult4b/xps succeeded
\end{lstlisting}

You can manually run one example by going to the `pcores/opb\_<design\_name>/design' subdirectory of the example and running `generateTMAPMake.py virtex2pro' from there (this has to be done only the first time). After this you can choose ``Download bitstream'' from within XPS (in version 13.4, you will need to run the application from Xilinx SDK).
The debug output of the FPGA can be read with minicom.

If you encounter errors, troubleshooting information can be found in Section~\ref{sec:xilinx_troubleshooting}.

\section{Setup your own DCS design on XPS 9.1}\label{sec:XPS9}
This tutorial guides you through the setup and implementation of a design with DCS. You can use it to start your own project or test it with the `xorExample' design. The steps below are the same for all Virtex II Pro FPGAs. All of these FPGAs have PowerPCs, which will be used to implement the DCS-aspects of the designs. In the guide below, the XUPV2P board was targeted. The next section describe the same process for Virtex 5 FPGAs.\\
\\
Step 1: Creating the project for the XUPV2P, p.\ \pageref{sec:creating_proj}\\
Step 2: Adding the HWICAP, p.\ \pageref{sec:adding_hwicap}\\
Step 3: Creating the DCS peripheral, p.\ \pageref{sec:creating_peripheral}\\
Step 4: Adding the DCS peripheral, p.\ \pageref{sec:adding_peripheral}\\
Step 5: Writing the DCS peripheral, p.\ \pageref{sec:writing_peripheral}\\
Step 6: Creating the software application, p.\ \pageref{sec:creating_software}\\
Step 7: Creating the custom makefile, p.\ \pageref{sec:creating_makefile}\\
Step 8: Writing the software application, p.\ \pageref{sec:writing_software}\\
Step 9: Testing, p.\ \pageref{sec:testing}\\
\\

%The FPGAs that uses MicroBlaze soft core processor to execute the DCS requires different steps and are described in  p.\ \pageref{sec:XPS13}.
%Bron: \url{http://hes.elis.ugent.be/wiki/Wiki/%20Dynamic%20reconfiguration/tmap-xps}


\subsection{Creating a project for the XUPV2P}\label{sec:creating_proj}

\begin{itemize}
\item Start XPS v9. Make sure that you have sourced the `source' file from the base directory of this repository in the same terminal as you start XPS in.
\item    Create a new project
\item    Chose the ``Base System Builder wizard''
\item    Chose the project directory
\item    Follow these steps:
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB1}
\caption{Choose to create a new design. Click Next\label{fig:BSB1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB2}
\caption{Choose Xilinx as board vendor. Choose the XUP board. Click Next\label{fig:BSB2}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB3}
\caption{Choose to use a the PowerPc. Click Next\label{fig:BSB3}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB4}
\caption{Choose 50MHz as Bus Clock Frequency (The ICAP can maximally handle 66MHz). Click Next\label{fig:BSB4}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB5}
\caption{Retain only the OPB\_UARTLITE in the next three windows\label{fig:BSB5}}
\end{figure}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.4]{BSB6}
%\caption{\label{fig:BSB6}}
%\end{figure}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.4]{BSB7}
%\caption{\label{fig:BSB7}}
%\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB8}
\caption{Use 64kB of memory. Click Next\label{fig:BSB8}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB9}
\caption{Choose the UART as STDIN and STDOUT. Don't generate sample applications. Click Next\label{fig:BSB9}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB10}
\caption{Generate the project. Click Generate\label{fig:BSB10}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB11}
\caption{Click Finish\label{fig:BSB11}}
\end{figure}


\subsection{Adding the HWICAP}\label{sec:adding_hwicap}
The HWICAP is used for run-time reconfiguration of the FPGA. This peripheral must be added to the project and connected to the OPB.
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{HWICAP1}
\caption{In the IP Catalog, double click ``OPB FPGA Internal Configuration Access Port''. Click Yes\label{fig:HWICAP1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{HWICAP2}
\caption{An instance of the opb\_hwicap appears in the System Assembly View. Connect the hwicap to the OPB\label{fig:HWICAP2}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{HWICAP3}
\caption{Open the MHS file by double clicking it in the Project tab. Search the opb\_hwicap instance and change the version from \emph{1.10.a} to \emph{1.00.b}\label{fig:HWICAP3}}
\end{figure}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.5]{HWICAP4}
%\caption{Open the MSS file by double clicking it in the Project tab. Search the opb\_hwicap instance and change the version from \emph{1.01.a} to \emph{1.00.b}\label{fig:HWICAP4}}
%\end{figure}
%
%Finally, create a symbolic link in the directory `drivers' (create the directory if needed) of your project to `examples/xorExample/xps/drivers/hwicap\_v1\_00\_b'.


\subsection{Creating the DCS peripheral}\label{sec:creating_peripheral}
Currently, DCS can only be done on exactly one peripheral of the OPB bus. In this section you create this OPB peripheral with memory mapped registers.
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP1}
\caption{Start the Create and Import Peripheral Wizard. Start the wizard from the Hardware menu. Click Next\label{fig:COIP1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP2}
\caption{Choose Create templates for a new peripheral. Click Next\label{fig:COIP2}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP3}
\caption{Choose to store the peripheral in the XPS project. Click Next\label{fig:COIP3}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP4}
\caption{Choose a name for the peripheral (E.g. `opb\_xor'). Click Next\label{fig:COIP4}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP5}
\caption{Choose to create an OPB peripheral. Click Next\label{fig:COIP5}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP6}
\caption{Choose for User logic S/W register support deselect S/W reset and MIR. Click Next\label{fig:COIP6}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP7}
\caption{Choose the required number and width of the registers. For the `xorExample' choose two 32-bit registers, one for the input and one for the output. Click Next\label{fig:COIP7}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP8}
\caption{Don't change anything. Click Next\label{fig:COIP8}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP9}
\caption{Don't change anything. Click Next\label{fig:COIP9}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP10}
\caption{Deselect Generate ISE and XPS project files. Click Next\label{fig:COIP10}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP11}
\caption{Click Finish\label{fig:COIP11}}
\end{figure}

\subsection{Adding the DCS peripheral}\label{sec:adding_peripheral}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{AXOR1}
\caption{In the IP Catalog, double click your OPB peripheral (E.g. `OPB\_XOR'). Click Yes.\label{fig:AXOR1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{AXOR2}
\caption{An instance of the peripheral appears in the System Assembly View. Connect the peripheral to the opb\label{fig:AXOR2}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{AXOR3}
\caption{Select the Addresses view in the System Assembly View. Click the Generate Addresses button\label{fig:AXOR3}}
\end{figure}


\subsection{Creating the software application}\label{sec:creating_software}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{soft1}
\caption{Double Click ``Add Software Application Project\dots'' in the Applications tab\label{fig:soft1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{soft2}
\caption{Right click  on the project. Click ``Mark to Initialize BRAMs'' in the pop down menu. Also unmark ppc405\_0\_bootloop\label{fig:soft2}}
\end{figure}


\subsection{Creating the custom makefile}\label{sec:creating_makefile}
\begin{itemize}
\item Choose  ``Generate netlist''. You may immediately terminate it once started.
\item Copy `system.make' to `custom.make' in your project directory.
\item In `custom.make', add the line ``include tmap.make'' right after ``include system\_incl.make''.
\item Click ``Project Options...'' in the ``Project'' menu and choose `custom.make' as the Custom Makefile (Figure~\ref{fig:makefile}).
\end{itemize}
Make sure that you  copy `system.make' after creating the software application. Do this again when you add new software applications.
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{make}
\caption{Choose `custom.make' as the Custom Makefile. Click Ok\label{fig:makefile}}
\end{figure}



\subsection{Writing the DCS peripheral}\label{sec:writing_peripheral}
\begin{itemize}
\item Go to the subdirectory corresponding to your DCS peripheral in the `pcores' directory of the project.
\item Copy the `hdl/vhdl' directory to the `design' directory. It should contain two files `opb\_<peripheral\_name>.vhd' and `user\_logic.vhd'.
\item Add the VHDL code of your DCS design to the `design' directory. It is advised that you run your design through the standalone TLUT tool flow first (Section\ \ref{sec:standalone_flow}). Add the line `-\--TMAP' to the top of the file that you want to perform DCS on. This does not have to be the top level module of the peripheral.
\item Add the names of your VHDL modules to the `.pao' file in the `data' directory. Modules that are only used as a submodule of your DCS module should not be included. Note that if a module depends on another module it should be listed after it.
\item Add the line ``OPTION CORE\_STATE = development'' to the `.mpd' file in the `data' directory to ensure that your peripheral is synthesized again if changes are made to it.
\item Instantiate your module in the architecture description of `user\_logic.vhd' and connect the inputs and outputs to the memory-mapped registers of the OPB peripheral. Assign the parameter inputs a dummy value.\\
E.g. for  `xorExample':
\lstset{language=VHDL}
\begin{lstlisting}
EXORS: entity work.exorw32
port map (
     a => slv_reg0,
     x => slv_reg1,
     p => (others => '0')
);
\end{lstlisting}
\item Remove the write functionality for read-only registers. For the `xorExample',  `slv\_reg1' is read-only (Figure~\ref{fig:design1}).
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{design1}
\caption{Removing the write functionality for read-only registers\label{fig:design1}}
\end{figure}
\item Enter the `design' directory and run `generateTMAPMake.py <your\_fpga>' with <your\_fpga> either ``virtex2pro'' or ``virtex5''. This creates the custom makefile `tmap.make'. You have to rerun `generateTMAPMake.py' if you add files to the DCS peripheral or change the `-\--TMAP' annotation.
\item Choose ``Generate bitstream'' in XPS to build your peripheral.
\item Look near the end of the output of this command for ``Group path: '' followed by something similar to ``opb\_xor\_0/opb\_xor\_0/USER\_LOGIC\_I/EXORS/*''.
Edit `data/system.ucf' and add the following lines before the IO constraints, replacing <group\_path> with the path found before. Enlarge the ``RANGE'' of the group as needed. This area constraint makes sure that  run-time reconfiguration does not break the rest of your design. This is necessary because reconfiguring a frame resets the contents of the SRLs and RAM LUTs in it. 

\lstset{language=}
\begin{lstlisting}
INST "<group_path>" AREA_GROUP=group1;
AREA_GROUP "group1" COMPRESSION=0;
AREA_GROUP "group1" RANGE=SLICE_X0Y*:SLICE_X51Y*;
\end{lstlisting}
%AREA_GROUP "group1" PLACE=CLOSED;
%AREA_GROUP "group1" GROUP=CLOSED;


\end{itemize}

\subsection{Writing the software application}\label{sec:writing_software}
\begin{itemize}
\item Choose ``Generate bitstream'' if you haven't already done this. This will create a number of C files in `swReconfiguration' that  contain the functions needed to perform run-time reconfiguration.
\item Under the applications tab, right click ``Sources'' and choose ``Add existing files\dots''. Add `swReconfiguration/locations.c' and `swReconfiguration/<TMAPmodule>.c' with TMAPmodule the name of the VHDL module that has the ``-\--TMAP'' annotation.
\item Right click ``Headers'' choose ``Add existing files\dots''. Add `swReconfiguration/locations.h' and `swReconfiguration/<TMAPmodule>.h'.
\item Right click ``Sources'' and choose ``Add new file\dots''. Call it `main.c' and save it.\\
You can find a template for your `main.c' file below or at the bottom of `swReconfiguration/<TMAPmodule>.h' (only for Virtex 2 Pro). Replace ``XPAR\_OPB\_XOR\_0\_BASEADDR'' with the name of the base address of your peripheral. You can find this in `Generated Header: ppc405\_0/include/xparameters.h' under  `Processor: ppc405\_0'.
\item Choose ``Build all user applications'' to build your software application.
\end{itemize}

\lstset{language=[ansi]C,showstringspaces=false}
\begin{lstlisting}
#include "<TMAPmodule>.h"

int main(void) {
	xil_printf("Starting EXOR test...\n\r\n\r");
	//Initialization
	static XHwIcap HwIcap;
	XHwIcap_Initialize(&HwIcap, HWICAP_DEVICEID, XHI_TARGET_DEVICEID);
	//Run-time reconfiguration
	Xuint8 i;
	Xuint8 parameter[NUMBER_OF_PARAMETERS];
	Xuint8 output[NUMBER_OF_INSTANCES][16];
	xil_printf("Configuring the LUTs for p=0...\n\r");
	for (i=0;i<NUMBER_OF_INSTANCES;i++) {
		//Reconfigure one instance
		parameter[0]=0;
		evaluate(parameter,output);
		reconfigure(&HwIcap,output,location_array[i]);
	}
	xil_printf("Configuration Complete!\n\r\n\r");
	//Testing configuration
	xil_printf("Writing 0xDEADBEAF to input register...\n\r");
	XIo_Out32(XPAR_OPB_XOR_0_BASEADDR,0xDEADBEAF);
	xil_printf("Reading output register: %x\n\r\n\r", 
		XIo_In32(XPAR_OPB_XOR_0_BASEADDR+4));
	xil_printf("End EXOR test.\n\r\n\r");
	return 1;
}
\end{lstlisting}

Explanation of the functions:\\
$evaluate(parameter, output)$ calculates the new truth table contents of the TLUTs for the new values of the parameters. The  values of the parameter signals have to be stored as boolean values in the $parameter$ array (one array element per signal line). The parameters are sorted alphabetically. You can check this ordering in `pcores/opb\_<your\_peripheral>/design/work/<TMAPmodule>.par'.\\
$reconfigure(\&HwIcap, output, location\_array[i])$ reconfigures the TLUTs of instance $i$ with the previously computed truth table contents. The instances are also sorted alphabetically. You can find this ordering in `swReconfiguration/locations.c'.


\subsection{Testing the design}\label{sec:testing}
The project can now be tested. To do this, connect your XUPV2P board to the computer using a USB cable (for bitstream programming) and a serial cable (for debugging). Start the program minicom to read the debug output from your XUPV2P board. Then, choose ``Download bitstream'' in XPS to run your project on the FPGA.

%\subsection{Differences for the Virtex 5}\label{sec:diff_virtex5}
%For the Virtex 5 FPGA the steps are similar but might look different because of the newer Xilinx Design Suite that is used.
%Summarised, you need to create a project (for the ML507 board) with a PowerPC, then add the HWICAP and connect it to the PLB bus (you don't have to change %the version of the HWICAP this time) and finally create a DCS peripheral in the same way as for the Virtex 2 Pro.

%In the new Design Suite you use Xilinx SDK to create software applications for your board. 
%To start SDK, choose ``Export Hardware Design to SDK'' under ``Project'' from within XPS. 
%Create a new software project and add all the files in ``swReconfiguration'' to your project. 
%You should link to the files but don't copy them because they are updated by the TLUT flow when you change your design. 
%Copy the file ``xhwicap\_clb\_lut\_replacement.h'' from ``examples/xorExample/xpsV13/swReconfiguration'' to your project. This fixes a bug in the HWICAP %drivers for Virtex 5.
%You may want to increase heap and stack size in the linker script of your software project.

%---------------X----------------------X------Amit-------------X---------------------X------
\section{Setup your own DCS design on XPS 13.4}\label{sec:XPS13}
As the previous section, this section guides you through the setup and implementation of a design with DCS, in this case on Virtex 5 FPGAs and using XPS13.4. You can use it to start your own project or test it with the `xorExample' design. The steps below use a MicroBlaze for implementing the DCS-aspects of the design, however, a PowerPC design has a similar setup. We describe the steps by considering ML507 board as a target and the same steps can be carried out for the Genesys board with small differences, described on p.\ \pageref{sec:diff_genesys}.\\
\\   
Step 1: Creating the project for the ML507, p.\ \pageref{sec:creating_proj_blaze}\\
Step 2: Adding the HWICAP, p.\ \pageref{sec:adding_hwicap_blaze}\\
Step 3: Creating the DCS peripheral, p.\ \pageref{sec:creating_peripheral_blaze}\\
Step 4: Adding the DCS peripheral, p.\ \pageref{sec:adding_peripheral_blaze}\\
Step 5: Writing the DCS peripheral, p.\ \pageref{sec:writing_peripheral_blaze}\\
%Step 6: Creating the software application, p.\ \pageref{sec:creating_software_blaze}\\
Step 6: Creating the custom makefile, p.\ \pageref{sec:creating_makefile_blaze}\\
Step 7: Writing the software application, p.\ \pageref{sec:writing_software_blaze}\\
Step 8: Testing, p.\ \pageref{sec:testing_blaze}\\
\\

%Bron: \url{http://hes.elis.ugent.be/wiki/Wiki/%20Dynamic%20reconfiguration/tmap-xps}


\subsection{Creating a project for the ML507}\label{sec:creating_proj_blaze}

\begin{itemize}
\item Start XPS v13. Make sure that you have sourced the `source' file from the base directory of this repository in the same terminal as you start XPS in.
\item    Create a XPS new project using BSB wizard
\item    Choose the ``PLB System'' as shown in figure~\ref{fig:step1}
\item    Choose the project directory
\item    Follow these steps:
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{step1}
\caption{Choose PLB System and choose the project directory. Click Next\label{fig:step1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{step2}
\caption{Choose ``I would like to create a new design". Click Next\label{fig:step2}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{step3}
\caption{Choose Xilinx as board and other options as depicted in the figure. Click Next\label{fig:step3}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{step4}
\caption{Choose single processor system [ While this was not tested, a dual processor system should work too.]. Click Next\label{fig:step4}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{step5}
\caption{Select MicroBlaze as a processor type with 66.67MHz(The ICAP can maximally handle 66MHz) and the local memory as 64KB (maximum). Click Next\label{fig:step5}}
\end{figure}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.4]{BSB6}
%\caption{\label{fig:BSB6}}
%\end{figure}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.4]{BSB7}
%\caption{\label{fig:BSB7}}
%\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{step6}
\caption{Retain only the RS232\_UART\_1, the dlim\_cntrl and the ilmb\_cntrl peripherals. Click Next\label{fig:step6}}
\end{figure}

Click the option `Next' in the Cache selection followed by `Generate' and then `Finish' in the summary window without any changes. A new project will be created according to your selection and window~\ref{fig:step9} appears.

\subsection{Adding the HWICAP}\label{sec:adding_hwicap_blaze}
The HWICAP is used for run-time reconfiguration of the FPGA. This peripheral must be added to the project and connected to the PLB.

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{step9}
\caption{In the IP Catalog tab, under FPGA Reconfiguration, double click the FPGA Internal XPS HWICAP. Click OK to add the IP and in Bus Interfaces tab, select ``mb\_plb" to connect the ICAP to the PLB bus\label{fig:step9}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{step10}
\caption{Click on the port tab, assign ``clock\_generator\_0" for the IP\_Clk\label{fig:step10}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{step11}
\caption{Click Generate Address button under Addresses tab\label{fig:step11}}
\end{figure}

\subsection{Creating the DCS peripheral}\label{sec:creating_peripheral_blaze}
Currently, DCS can only be done on exactly one peripheral of the PLB bus. In this section you create this PLB peripheral with memory mapped registers.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{step12}
\caption{Start the Create and Import Peripheral wizard. Start the wizard from the Hardware menu. Click Next\label{fig:step12}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{step13}
\caption{Choose Create templates for a new peripheral. Click Next\label{fig:step13}}
\end{figure} 

Click Next in the ``Repository or Project" window without any changes.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{step15}
\caption{Choose a name for the peripheral (E.g. `plb\_xor'). Click Next\label{fig:step15}}
\end{figure}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.5]{HWICAP4}
%\caption{Open the MSS file by double clicking it in the Project tab. Search the opb\_hwicap instance and change the version from \emph{1.01.a} to \emph{1.00.b}\label{fig:HWICAP4}}
%\end{figure}
%
%Finally, create a symbolic link in the directory `drivers' (create the directory if needed) of your project to `examples/xorExample/xps/drivers/hwicap\_v1\_00\_b'.



\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{step16}
\caption{Choose to create an PLB peripheral. Click Next\label{fig:step16}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{step17}
\caption{Choose ``User logic S/W register support" and deselect ``Include data phase time". Click Next\label{fig:step17}}
\end{figure}

In the 'Slave Interface'-window, Click Next without any changes.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{step19}
\caption{Select the number of software accessible registers as 2 [project specific]. Click Next\label{fig:step19}}
\end{figure}

Click Next, for both the `IPIC' and `Peripheral simulation support window' without any changes.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{step21}
\caption{Deselect Generate ISE and XPS project files. Click Next\label{fig:step21}}
\end{figure}

\subsection{Adding the DCS peripheral}\label{sec:adding_peripheral_blaze}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{step23}
\caption{In the IP Catalog, double click your PLB peripheral (E.g. `PLB\_XOR'). An instance of the peripheral appears in the System Assembly View. Connect the peripheral to the plb\label{fig:step23}}
\end{figure}

Finally, click Generate address button under `Addresses' tab.

%TODO: HIER ANDERE VOLGORDE!

%\subsubsection{Creating the software application}\label{sec:creating_software_blaze}
%The steps for creating software application for MicroBlaze target is same as steps mentioned for PowerPC target. Please refer p.\ \pageref{sec:creating_software}.

\subsection{Writing the DCS peripheral}\label{sec:writing_peripheral_blaze}

The steps for writing the DCS peripheral are exactly the same as for the XPS 9.1 flow. See p.\ \pageref{sec:writing_peripheral} for a more detailed description.
The last part of this step - Defining area the constraints - can be left out for Virtex 5 FPGAs.

\subsection{Creating the custom makefile}\label{sec:creating_makefile_blaze}

Once the DCS peripheral has been defined completely, it is necessary to define a custom makefile. This is described in p.\ \pageref{sec:creating_makefile}. If you have not done so already, do not forget to enter the `design' directory and run `generateTMAPMake.py <your\_fpga>' with <your\_fpga> either ``virtex2pro'' or ``virtex5''. This creates the custom makefile `tmap.make', which insures the TLUT toolflow hooks up correctly with the Xilinx tools. Rerun `generateTMAPMake.py' if you add files to the DCS peripheral or change the `-\--TMAP' annotation.

\subsection{Writing the software application}\label{sec:writing_software_blaze}

The previous steps conclude the hardware part of the XPS 13.4 flow, in order to write the software application and to test the design, we will continue in the Xilinx SDK, an eclipse-based software IDE which allows the user to program the FPGA and debug as well. The following steps have to be carried out:
\\   
Step 1: Exporting the hardware design to Xilinx SDK, p.\ \pageref{sec:expot_sdk_blaze}\\
Step 2: Creating an application project, p.\ \pageref{sec:creating_application_blaze}\\
Step 3: Importing the software, p.\ \pageref{sec:import_software_blaze}\\

\begin{itemize}
\item \textbf{Exporting the hardware design to Xilinx SDK (XSDK):}\label{sec:expot_sdk_blaze}\\
Now the hardware has been defined completely, the bitstream can be generated and exported to the XSDK. Click the button `Export design' present in the navigator panel and follow the steps shown below:

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{softwarestep1}
\caption{Click on ``Export \& Launch SDK". This will open XSDK. \label{fig:softwarestep1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{softwarestep2}
\caption{Select ``Empty Application". Click Next \label{fig:softwarestep2}}
\end{figure}

\item \textbf{Creating an application project:}\label{sec:creating_application_blaze}\\
The SDK window is now ready to create the application. Click `File' in the Menu bar followed by `Xilinx C Project' and follow the steps below.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{softwarestep4}
\caption{Give your suitable location for workspace (Eg./home/user/blaze\_V5\_ML507). A new folder with ``blaze\_V5\_ML507" will be created where are the SDK files are stored.  \label{fig:softwarestep4}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{softwarestep5}
\caption{Create a new BSP project. Click Finish \label{fig:softwarestep5}}
\end{figure}

\item \textbf{Importing the software:}\label{sec:import_software_blaze}\\
The software-files needed for using DCS are all generated by the tool flow and put in the ``swReconfiguration" folder by default. To add them, locate the folders in the `Project Explorer' window. Right Click on the `src' folder and select `Import ' and follow the steps below. For more details on the generated files themselves, refer to p. \pageref{sec:writing_software}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{softwarestep6}
\caption{Select the ``File System". Click Next \label{fig:softwarestep6}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{softwarestep7}
\caption{Browse to the project folder containing the application software (Eg.``swReconfiguration" folder). Link the software-files from your project folder by clicking ``Advanced" button, this insures the project will always contain the most recent software files. Click Finish \label{fig:softwarestep7}}
\end{figure}

Once all the application software is imported, XSDK compiles the code automatically. Errors (if any) will be shown in the console window. Some of the common errors are discussed in the Troubleshooting section (p \pageref{sec:xilinx_troubleshooting}).

\subsection{Testing the design}\label{sec:testing_blaze}
Step 1: Programming the FPGA, p.\ \pageref{sec:program_FPGA_blaze}\\
Step 2: Verifying the design using Minicom, p.\ \pageref{sec:verifying_minicom_blaze}\\
\\

\item \textbf{Programming the FPGA}\label{sec:program_FPGA_blaze}\\
After compilation, a working .elf file is created. This is the binary that runs on the FPGA. Once the .bit file and the .elf file are ready, we can proceed to program the FPGA. 

Turn ON your FPGA, connect the RS32 cable and the JTAG programmer with USB. Click on the ``Xilinx Tools" option in the Menu bar of the SDK, select ``Program FPGA". Next, select the application to be loaded into the FPGA, as in Figure \ref{fig:softwarestep8}.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{softwarestep8}
\caption{Select the .elf file in the ``Software Congifuration". Click Program\label{fig:softwarestep8}}
\end{figure}

\item \textbf{Verifying the design using Minicom}\label{sec:verifying_minicom_blaze}\\ 
Open Minicom from a terminal, the XOR-example writes the test status using serial communication RS232. The FPGA starts by sending, `Starting EXOR test...' and follows up by reporting the results of different tests. 

\end{itemize}

\subsection{Differences for the Genesys development board}\label{sec:diff_genesys}
The Genesys board was built by Digilent as a development platform for Virtex 5 FPGAs. Our board contains a Virtex 5 XC5VLX50T. It has no on-board PowerPC so DCS is implemented using a MicroBlaze softcore processor.

This changes the Project Setup described above slightly, the main differences are listed below:
\begin{itemize}
\item \textbf{Selecting the board configuration for the Genesys board}: \\
While selecting the board during creation of your project p.\ \pageref{sec:creating_proj_blaze}, In figure~\ref{fig:step3}, select Genesys as the board vendor. If the option is not available, source the Genesys support library, which can be found on their \href{http://www.digilentinc.com/Products/Detail.cfm?Prod=GENESYS}{website}.

Go to Edit menu of the XPS menu bar, click on Edit preferences and follow the steps.
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{genesys_diff1}
\caption{Provide the genesys library path in the ``Global Peripheral Repository Search Path".  Click Apply and OK. Restart XPS\label{fig:genesys_diff1}}
\end{figure}

\item \textbf{Selecting the Programming cable for the Genesys board}: \\
Before programming the FPGA as explained in the figure~\ref{fig:softwarestep8}, go to `XilinxTools menu' of the SDK menu bar, click on `Configure JTAG settings' and follow the steps.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{genesys_diff2}
\caption{Select the ``Xilinx USB cable" as JTAG cable type. Click OK\label{fig:genesys_diff2}}
\end{figure}

\end{itemize}

\subsection{Differences for the XUPV5  development board}\label{sec:diff_genesys}
This board contains a Virtex 5 XC5VLX110T. It has no on-board PowerPC so DCS is implemented using a MicroBlaze softcore processor.

This changes the Project Setup described above slightly, the main differences are listed below:
\begin{itemize}

\item \textbf{Selecting the board configuration for the XUPV5 board}: \\
While selecting the board during creation of your project p.\ \pageref{sec:creating_proj_blaze}, In figure~\ref{fig:step3}, select Xilinx as the board vendor, followed by board name as `Virtex 5 ML505 Evaluation Platform'. You might notice that the selected FPGA would be Virtex 5 XC5VLX50T, however the configuration is same for Virtex 5 XC5VLX110T.

While sourcing the `custom.make' file shown in p. \pageref{sec:creating_makefile}, figure~\ref{fig:makefile}, select the archictecture as Virtex 5, Device size as XC5VLX110T and then finally source the custom.make file as explained before.

\end{itemize}

%--------------X--------------------------X------Amit------------X-----------------------X---
\section{Troubleshooting}\label{sec:xilinx_troubleshooting}


It is assumed that you have already successfully run the tests for the standalone TLUT tool flow (Section~\ref{sec:standalone_flow}).

\begin{itemize}
\item \emph{Throws ``tmapXilinx.py: Command not found'':}\\
Make sure you have set the environment variables correctly by doing `. source'. You must do this in the same terminal as you start XPS in and before starting XPS.
\item \emph{The output of minicom is garbage:}\\
Reboot your computer to fix the corrupted state the serial port is in. The corrupted state may be caused by running minicom and `virtex2pro\_test.sh' at the same time.
\item \emph{Xilinx Design Suite Errors:}\\
Make sure you are using a compatible version of the Design Suite. Version 9 for the Virtex 2 Pro and a newer one for the Virtex 5 (For the recommended versions see Section~\ref{sec:setup}).
\item \emph{XSDK compilation generates a memory overlap error:}\\
There are several options here, first, try to increase the memory size allocation to the instruction and data-memory of the MicroBlaze or PowerPC. This can be done in XPS. There are limits on how much this size can be increased, however, so a second option is to increase the size listed for the data and instruction memory in the linker script in XSDK. 
\item \emph{Only ``Starting EXOR test" and/or garbage is printed in minicom:}\\
This can occur if the Heap and/or Stack are not allocated enough memory. The size of both can be increased through the linker script in XSDK or in XPS 9.1
\item \emph{Reconfiguration does not happen, even for the example designs:}\\
Check the jumper settings of the XUPV2P or ML507 board.
\item \emph{No Messages found in Minicom after programming FPGA in Genesys board}\\
Check the RS232 port connection in the project UCF file. The master UCF file for Genesys board is located at: git/tlut\_flow/Digilent\_Genesys. Compare both ucf files, it could be you are listening to the wrong UART interface. Change the UCF file to use the other set of ports for the UART interface and rerun the flow. This should generate a new bitstream.
\end{itemize}




\clearpage
\chapter{Contents}\label{sec:contents}
The `tlut\_flow' folder contains a number of folders and three files: `Makefile', `README.md' and `LICENSE'. 
The `Makefile' is used to initially set up the tool flow. It will download  some necessary third party tools and compile the used programs.
More information about the license under which the TLUT tool flow is released can be found in `LICENSE'.\\

The `tlut\_flow' folder contains the following folders:  `examples', `tests', `documentation',  `java', `python' and `third\_party'.

\begin{itemize}
\item In the `examples' folder you can find a number of designs that use the TLUT tool flow. You can run each of them by executing the Python script contained in the respective subfolder. You can run all examples at once (except AES) by executing the `run\_all.sh' script.
\item In the `tests' folder you can currently find one test, namely `examples\_test.sh'. Executing this script will run the `examples/run\_all.sh' script and compare the output to the expected output.
\item The `documentation' folder contains this document, and its Latex source files, and the Ph.D. thesis by Karel Bruneel which contains more information about the academic underpinnings of the TLUT tool flow.
\end{itemize}

The remaining folders contain binaries, source code and wrapper scripts. You may want to edit these when doing advanced experiments.
\begin{itemize}
\item The `java' folder contains the Java source and binary files of a simple technology mapper and an adapted parameterized version of this technology mapper, the TLUT technology mapper.
\item After setup, the `third\_party' folder will contain ABC, the logic synthesis and technology mapping tool of the university of Berkeley, and Aiger, a tool used to handle textual (.aag) and binary representations of and-inverter-graphs (.aig).    

\item The `python' folder contains the high level Python scripts that are used to interface with the tools in the other folders. It contains three files: `fast\_tlutmap.py', `genParameters.py' and `mapping.py'. The `genParameters.py' script will extract the parameters from the annotated VHDL file. The `mapping.py' script contains high level wrappers that call the different mappers and a number of utility programs. These 2 last scripts are best used as given. 

The `fast\_tlutmap.py' script contains the main code in the `run' function. This function can easily be adjusted to meet the user's needs. The run function mainly consists of 2 steps: synthesis and technology mapping. The synthesis step converts the VHDL file into a logic circuit in blif format using Quartus II. The technology mapping step will map the logic circuit to a circuit with LUTs. Three different technology mapping tools are included to allow an easy comparison: the simple mapper, the TLUT technology mapper and the ABC mapper. The first two are not as optimized as ABC. For example `area recovery' is not yet completely implemented. The ABC tool flow is an academic framework that does include a large number of such optimizations. Several commercial tools are based on this technology mapper.

The `run' function also contains some intermediate steps:
\begin{itemize} 
\item the conversion of the blif format into the aag format, needed for the Java mappers
\item extraction of the parameters out of the annotated VHDL file
\end{itemize}

\end{itemize}

%Hier zouden ook nog alle voorbeelden moeten beschreven worden, vanaf welke formaat ze starten (vhdl, verilog, aag) en een zin over wat ze moeten voorstellen.



\end{document}
