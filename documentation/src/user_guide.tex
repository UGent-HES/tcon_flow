\documentclass[a4paper,oneside]{memoir}
\usepackage{listings}%
\usepackage{xcolor}
\usepackage{hyperref}
\lstset{%
    backgroundcolor=\color{yellow!20},%
    basicstyle=\small\ttfamily,%
    numbers=none, numberstyle=\tiny, stepnumber=2, numbersep=5pt,%
    }%

\lstset{emph={%  
    PARAM%
    },emphstyle={\color{blue}\bfseries},%
    morekeywords={filename},
    keywordstyle={\color{red}\ttfamily}
}%

\usepackage{fourier} % or what ever
\usepackage[scaled=.92]{helvet}%. Sans serif - Helvetica
\usepackage{color,calc}
\newsavebox{\ChpNumBox}
\definecolor{ChapBlue}{rgb}{0.00,0.65,0.65}
\makeatletter
\newcommand*{\thickhrulefill}{%
  \leavevmode\leaders\hrule height 1\p@ \hfill \kern \z@}
\newcommand*\BuildChpNum[2]{%
  \begin{tabular}[t]{@{}c@{}}
    \makebox[0pt][c]{#1\strut}  \\[.5ex]
    \colorbox{ChapBlue}{%
      \rule[-10em]{0pt}{0pt}%
      \rule{1ex}{0pt}\color{black}#2\strut
      \rule{1ex}{0pt}}%
  \end{tabular}}
\makechapterstyle{BlueBox}{%
  \renewcommand{\chapnamefont}{\large\scshape}
  \renewcommand{\chapnumfont}{\Huge\bfseries}
  \renewcommand{\chaptitlefont}{\raggedright\Huge\bfseries}
  \setlength{\beforechapskip}{0pt}
  \setlength{\midchapskip}{26pt}
  \setlength{\afterchapskip}{40pt}
  \renewcommand{\printchaptername}{}
  \renewcommand{\chapternamenum}{}
  \renewcommand{\printchapternum}{%
    \sbox{\ChpNumBox}{%
      \BuildChpNum{\chapnamefont\@chapapp}%
      {\chapnumfont\thechapter}}}
  \renewcommand{\printchapternonum}{%
    \sbox{\ChpNumBox}{%
      \BuildChpNum{\chapnamefont\vphantom{\@chapapp}}%
      {\chapnumfont\hphantom{\thechapter}}}}
  \renewcommand{\afterchapternum}{}
  \renewcommand{\printchaptertitle}[1]{%
    \usebox{\ChpNumBox}\hfill
    \parbox[t]{\hsize-\wd\ChpNumBox-1em}{%
      \vspace{\midchapskip}%
      \thickhrulefill\par
      \chaptitlefont ##1\par}}%
}
\chapterstyle{BlueBox}

\setlength\afterchapskip {\onelineskip }
\setlength\beforechapskip {\onelineskip }
\usepackage{lipsum}

%\setlength{\oddsidemargin}{0.03\paperwidth} 
%\setlength{\evensidemargin}{0.03\paperwidth}
%\setlength{\textwidth}{0.7\paperwidth}
%\setlength{\voffset}{0pt}

%\usepackage{anysize}
%\marginsize{2.25cm}{2cm}{}{1,25 cm}
\setlrmarginsandblock{3cm}{2.5cm}{*}
\setulmarginsandblock{2.5cm}{2.5cm}{*}
\checkandfixthelayout



\begin{document}

\let\clearforchapter\par % cheating, but saves some space
\chapter{The TLUT tool flow: An introduction}

The TLUT tool flow is a tool flow that generates FPGA configurations. Its biggest difference with the traditional FPGA flow is the use of a new technology mapper, the TLUT mapper. The TLUT tool flow was developed to implement Dynamic Circuit Specialization (DCS) on FPGAs. A DCS implementation of an application specializes its circuit for the current values of a number of specific inputs, called parameters. This specialized circuit is smaller, and in some cases faster, than the original circuit. However, it is only correct for one set of parameter values. Each time the parameters change value, a new specialized circuit is generated. This new specialized circuit is then loaded into the FPGA using partial run-time reconfiguration.\\

The TLUT tool flow offers an efficient implementation of DCS because it uses the concept of parameterized configurations. A parameterized configuration is a configuration in which some bits are expressed as Boolean functions of the parameters. Before the FPGA can be configured, the parameter values are used to evaluate the Boolean functions. This generates the specialized configuration. Several papers on the academic underpinnings of the TLUT tool flow are listed in the wiki of this project. There you can also find more information on our current research on extending and improving the TLUT tool flow. The TLUT tool flow itself and how to use it, is described in much more detail in this user guide.

\section{Roadmap}

We are releasing the TLUT tool flow in two phases. First, we have made the adapted TLUT technology mapper public. This will allow you to compare its results with a conventional technology mapper. We have included a framework to make this comparison very easy. The following pages provide clear examples and show how to adapt the framework for you own uses.\\

In the second phase, which will be released soon, we will provide you with the scripts and information necessary to integrate the TLUT technology mapper with the Xilinx FPGA tool flow. This will allow you to implement your DCS implementations on commercial Xilinx FPGAs. Our first target FPGA is the Virtex II Pro. We are currently working on extending this tool flow to more modern FPGAs, such as the Virtex 5 or 6.

\section{Contact information}
The TLUT tool flow is released by Ghent University, ELIS department, Hardware and Embedded Systems (HES) group (\href{http://hes.elis.ugent.be}{\emph{hes.elis.ugent.be}}).

If you encounter bugs, want to use the TLUT tool flow but need support or want to tell us about your results, feel free to contact us.
We can be reached at \href{mailto:hes@elis.ugent.be}{\emph{hes@elis.ugent.be}}.


\section{Contents of this document}
Chapter~\ref{sec:setup}: \emph{Setup}: A setup manual\\
Chapter~\ref{sec:experiment}: \emph{Your design}: A manual for running your own experiments\\
Chapter~\ref{sec:troubleshooting}: \emph{Troubleshooting}: Problems you may encounter and their solutions\\
Chapter~\ref{sec:contents}: \emph{Contents}: Description of the contents of this package


\clearpage
\chapter{Setup}\label{sec:setup}
\begin{lstlisting}
> make
\end{lstlisting}
This builds a number of dependencies and the TLUT technology mapper and creates a `source' file which sets environment variables. Set your environment variables using:
\begin{lstlisting}
> . source
\end{lstlisting}

Your installation can be tested using the script in directory `tests'.
\begin{lstlisting}
> cd tests
> ./examples_test.sh
\end{lstlisting}

Examples can be run using the included Python scripts.
E.g.
\begin{lstlisting}
> cd examples/treeMult4b
> ./treeMult4b.py
\end{lstlisting}

\section{Dependencies}
\begin{itemize}
\item Dependencies to be provided by the user:\\
Python (tested with version 2.7), \url{http://www.python.org}\\
Quartus II (tested with version 10.0), Altera Corporation, \url{http://www.altera.com}
\item Dependencies automatically downloaded and installed:\\
Aiger (tested with version 1.9.4), JKU Institute for Formal Models and Verification, \url{http://fmv.jku.at/aiger}\\
ABC (tested with version 810ba683c042, 5 October 2012), Berkeley Logic Synthesis and Verification Group, \url{http://www.eecs.berkeley.edu/\~alanmi/abc}
\end{itemize}

\clearpage
\chapter{Your own design}\label{sec:experiment}
\section{The run function}\label{sec:run_function}
To test the TLUT mapper on your own design (described in VHDL or Verilog), import the \emph{run} function from \emph{fast\_tlutmap} in your own Python script and call it with the following arguments:
\begin{lstlisting}
run(module, submodules, K, performCheck, verboseFlag)
\end{lstlisting}
\begin{itemize}
\item \textbf{module} - String\\
The location of the top level of your design. If your design consists of only one VHDL/Verilog module, then you only have to pass the location of this module as the first argument and you can ignore the second argument.\\

E.g. run('yourDesign.vhd')

\item \textbf{submodules} - list of Strings - \textit{optional}\\
If your design consists of a top level module and several submodules, you can add a list of submodules here, for example if you have one top level module and two submodules.\\

E.g. run('yourTopLevelModule.vhd', ['yourFirstSubModule.vhd', 'yourSecondSubModule.vhd'])

\item \textbf{K} - integer - \textit{default 4}\\
You can choose the number of inputs a LookUp Table has on your target FPGA\\

E.g. run('yourDesign.vhd', 6)
or run('yourDesign.vhd', K=6)

\item \textbf{performCheck} - boolean - \textit{default True}\\
When checks are turned on, the resulting mapping is verified using a miter and satisfiability solver. This ensures that the mapped circuit implements the same functionality as the input circuit.\\

E.g. run('yourDesign.vhd', 6, True)\\
or run('yourDesign.vhd', performCheck=False)

\item \textbf{verboseFlag} - boolean - \textit{default False}\\
This activates the verbose mode in which more information gets printed regarding the execution of the flow.\\

E.g. run('yourDesign.vhd', 6, True, True)\\ or run('yourDesign.vhd', verboseFlag=True)
\end{itemize}

\section{A Step-by-step Approach}\label{sec:step_by_step}
Below, we have provided a more step-by-step approach to set up your own Python script starting from the \emph{treeMult4b} example:
\begin{enumerate}
\item Make a folder for your design and copy the treeMult4b folder from the examples directory. You need at least the files \emph{abc.rc} and \emph{treeMult4b.py}\\
\begin{lstlisting}
> mkdir yourDesign
> cp -r examples/treeMult4b/* yourDesign/
\end{lstlisting}
\item Replace treeMult4.vhd by copying your VHDL/Verilog files, describing your design, into the \emph{yourDesign}-folder\\
\begin{lstlisting}
> rm treeMult4b.vhd
> 
\end{lstlisting}
\item Annotate the parameters in your top level VHDL/Verilog file.\\

Any input signal, or combination of input signals, of your top level module can be chosen as parameter. Preferably the designer will choose the slowly changing input signals as parameters, because a change in the value of the parameters results in a reconfiguration of the FPGA. Different combinations can be tested easily by changing the annotations. In the following example a simple multiplexer is described in VHDL and the 'sel' input signal is annotated as a parameter.
\lstset{language=VHDL}
\begin{lstlisting}
entity multiplexer is
port(
  --PARAM
  sel : in  std_logic_vector(1 downto 0);
  --PARAM
  in  : in  std_logic_vector(3 downto 0);
  out : out std_logic
);
end multiplexer;

architecture behavior of multiplexer is
begin
  out <= in(conv_integer(sel));
end behavior;
\end{lstlisting}
The Verilog annotations are quite similar. The following Verilog example, a simple multiplier, can be found in the examples folder;
\lstset{language=Verilog}
\begin{lstlisting}
module mult(x,y,z);
parameter N = 16;
input [N-1:0] x;
//PARAM
input [N-1:0] y;
//PARAM
output [2*N-1:0]z;
assign z = x * y;
endmodule
\end{lstlisting}
 
\item Modify the Python script\\
\begin{lstlisting}
> mv treeMult4b.py yourDesign.py
> nano yourDesign.py
\end{lstlisting}
Edit the 6th line, in which the \emph{run} function is called, according to the documentation in section~\ref{sec:run_function}.
\item Run the modified Python script
\begin{lstlisting}
> ./yourDesign.py
\end{lstlisting}
\item \label{sec:check_par}Check the `.par' file in the work directory, to ensure the parameters were correctly recognised. It should enlist all the signal names of the parameters. \\
The tool for extracting parameters from VHDL and Verilog is limited. It cannot parse all VHDL/Verilog constructs, so it may not recognise all your parameters in all cases. You should avoid using signal types other than std\_logic, std\_logic\_vector and arrays thereof. In addition, only one definition is allowed per line. Similarly, only one Generic (or Verilog parameters) used in the definition of the parameter signals should be defined per line.

\item Analyze the results. As an example, the output of the Python script of the treeMult4b project is given;\\

\begin{lstlisting}
Stage: TLUT mapper
Luts (TLUTs)     depth     check
12.0 (12.0)      2.0       PASSED    
Stage: SimpleMAP
Luts             depth     check     
69.0             11.0      PASSED    
Stage: ABC fpga
Luts             depth     check     
67.0             10.0      PASSED 
\end{lstlisting}

The first column shows the number of LUTs in each mapping solution. These can be compared directly and represents the number of K-LUTs needed to implement the design. In this case, the TLUT mapper needs 12 LUTs, SimpleMAP 69 and ABC fpga 67.

The second column is only relevant for the TLUT mapper, it shows the number of LUTs that will actually be reconfigured at run-time. We call these LUTs TLUTs. In this case all 12 of the LUTs are TLUTs and will be reconfigured at run-time.

The third column shows the depth of each mapping solution. This is the number of LUTs in the longest path, a measure for the speed of the circuit. 

Finally, column 4 shows if the mapping solution has passed the equivalence test. This check is performed to see if the resulting circuit still has the same functionality as the original input.

% Hier de verschillen tussen simpleMap en abc bespreken of later pas in hoofdstuk 4?

\end{enumerate}

\section{Advanced}
It is also possible to start from an `.aag' or `.blif' file. As a reference for this we provide examples \emph{AES} and \emph{tripleDES}. 
Advanced experiments can be set up by copying \emph{fast\_tlutmap} and using this file as a template for your experiment.

\clearpage
\chapter{Troubleshooting}\label{sec:troubleshooting}
Try running one of the examples (in the examples folder) first. If this works as expected your environment is set up correctly.\\

These are a few common errors and their solution:
\begin{itemize}
\item \emph{Python ImportError: No module named fast\_tlutmap (or others):}\\
The environment variables probably aren't set up correctly. Try running `. source' in the main directory. 
If you have moved the main directory, the paths in the `source' file are not longer correct. Remove this file and recreate it using `make source'.

\item \emph{java.lang.OutOfMemoryError:}\\
The Java technology mappers don't have enough memory available. Try to use the \emph{setMaxMemory} function. It can be imported from the \emph{fast\_tlutmap} Python script and should be called before the \emph{run} function. This function sets the maximum memory usage for the Java tools in megabytes.
\lstset{language=python}
\begin{lstlisting}
from fast_tlutmap import run, setMaxMemory

setMaxMemory(4096)
run('treeMult4b.vhd', K=4, performCheck=True, verboseFlag=False)
\end{lstlisting}

\item \emph{The number of TLUTs is 0, or the reduction in number of LUTs is lower than expected:}\\
Check if all parameters were correctly extracted from your VHDL/Verilog. See section~\ref{sec:step_by_step}, step~\ref{sec:check_par}.
\end{itemize}

\clearpage
\chapter{Contents}\label{sec:contents}
The `tlut\_flow' folder contains a number of folders and three files: `Makefile', `README.md' and `LICENSE'. 
The `Makefile' is used to initially set up the tool flow. It will download  some necessary third party tools and compile the used programs.
More information about the license under which the TLUT tool flow is released can be found in `LICENSE'.\\

The `tlut\_flow' folder contains the following folders:  `examples', `tests', `documentation',  `java', `python' and `third\_party'.

\begin{itemize}
\item In the `examples' folder you can find a number of designs that use the TLUT tool flow. You can run each of them by executing the Python script contained in the respective subfolder. You can run all examples at once (except AES) by executing the `run\_all.sh' script.
\item In the `tests' folder you can currently find one test, namely `examples\_test.sh'. Executing this script will run the `examples/run\_all.sh' script and compare the output to the expected output.
\item The `documentation' folder contains this document, and its Latex source files.
\end{itemize}

The remaining folders contain binaries, source code and wrapper scripts. You may want to edit these when doing advanced experiments.
\begin{itemize}
\item The `java' folder contains the Java source and binary files of a simple technology mapper and an adapted parameterized version of this technology mapper, the TLUT technology mapper.
\item After setup, the `third\_party' folder will contain ABC, the logic synthesis and technology mapping tool of the university of Berkeley, and Aiger, a tool used to handle textual (.aag) and binary representations of and-inverter-graphs (.aig).    

\item The `python' folder contains the high level Python scripts that are used to interface with the tools in the other folders. It contains three files: `fast\_tlutmap.py', `genParameters.py' and `mapping.py'. The `genParameters.py' script will extract the parameters from the annotated VHDL file. The `mapping.py' script contains high level wrappers that call the different mappers and a number of utility programs. These 2 last scripts are best used as given. 

The `fast\_tlutmap.py' script contains the main code in the `run' function. This function can easily be adjusted to meet the user's needs. The run function mainly consists of 2 steps: synthesis and technology mapping. The synthesis step converts the VHDL file into a logic circuit in blif format using Quartus II. The technology mapping step will map the logic circuit to a circuit with LUTs. Three different technology mapping tools are included to allow an easy comparison: the simple mapper, the TLUT technology mapper and the ABC mapper. The first two are not yet optimized for `area recovery'. The ABC tool flow is an academic framework that does include a large number of such optimizations. Several commercial tools are based on this technology mapper.

The `run' function also contains some intermediate steps:
\begin{itemize} 
\item the conversion of the blif format into the aag format, needed for the Java mappers
\item extraction of the parameters out of the annotated VHDL file
\end{itemize}

\end{itemize}

%Hier zouden ook nog alle voorbeelden moeten beschreven worden, vanaf welke formaat ze starten (vhdl, verilog, aag) en een zin over wat ze moeten voorstellen.



\end{document}
