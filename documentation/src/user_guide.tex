\documentclass[a4paper,oneside]{memoir}
\usepackage{listings}%
\usepackage{xcolor}
\usepackage{hyperref}
\lstset{%
    backgroundcolor=\color{yellow!20},%
    basicstyle=\small\ttfamily,%
    numbers=none, numberstyle=\tiny, stepnumber=2, numbersep=5pt,%
    }%

\lstset{emph={%  
    PARAM%
    },emphstyle={\color{blue}\bfseries},%
    morekeywords={filename},
    keywordstyle={\color{red}\ttfamily}
}%

\usepackage{fourier} % or what ever
\usepackage[scaled=.92]{helvet}%. Sans serif - Helvetica
\usepackage{color,calc}
\newsavebox{\ChpNumBox}
\definecolor{ChapBlue}{rgb}{0.00,0.65,0.65}
\makeatletter
\newcommand*{\thickhrulefill}{%
  \leavevmode\leaders\hrule height 1\p@ \hfill \kern \z@}
\newcommand*\BuildChpNum[2]{%
  \begin{tabular}[t]{@{}c@{}}
    \makebox[0pt][c]{#1\strut}  \\[.5ex]
    \colorbox{ChapBlue}{%
      \rule[-10em]{0pt}{0pt}%
      \rule{1ex}{0pt}\color{black}#2\strut
      \rule{1ex}{0pt}}%
  \end{tabular}}
\makechapterstyle{BlueBox}{%
  \renewcommand{\chapnamefont}{\large\scshape}
  \renewcommand{\chapnumfont}{\Huge\bfseries}
  \renewcommand{\chaptitlefont}{\raggedright\Huge\bfseries}
  \setlength{\beforechapskip}{0pt}
  \setlength{\midchapskip}{26pt}
  \setlength{\afterchapskip}{40pt}
  \renewcommand{\printchaptername}{}
  \renewcommand{\chapternamenum}{}
  \renewcommand{\printchapternum}{%
    \sbox{\ChpNumBox}{%
      \BuildChpNum{\chapnamefont\@chapapp}%
      {\chapnumfont\thechapter}}}
  \renewcommand{\printchapternonum}{%
    \sbox{\ChpNumBox}{%
      \BuildChpNum{\chapnamefont\vphantom{\@chapapp}}%
      {\chapnumfont\hphantom{\thechapter}}}}
  \renewcommand{\afterchapternum}{}
  \renewcommand{\printchaptertitle}[1]{%
    \usebox{\ChpNumBox}\hfill
    \parbox[t]{\hsize-\wd\ChpNumBox-1em}{%
      \vspace{\midchapskip}%
      \thickhrulefill\par
      \chaptitlefont ##1\par}}%
}
\chapterstyle{BlueBox}

\setlength\afterchapskip {\onelineskip }
\setlength\beforechapskip {\onelineskip }

%\setlength{\oddsidemargin}{0.03\paperwidth} 
%\setlength{\evensidemargin}{0.03\paperwidth}
%\setlength{\textwidth}{0.7\paperwidth}
%\setlength{\voffset}{0pt}

%\usepackage{anysize}
%\marginsize{2.25cm}{2cm}{}{1,25 cm}
\setlrmarginsandblock{3cm}{2.5cm}{*}
\setulmarginsandblock{2.5cm}{2.5cm}{*}
\checkandfixthelayout

\usepackage{graphicx}
\usepackage{float}
\graphicspath{{./img/}}
\DeclareGraphicsExtensions{.pdf,.jpeg,.png}


\begin{document}

\let\clearforchapter\par % cheating, but saves some space
\chapter{The TLUT tool flow: An introduction}

The TLUT tool flow is a tool flow that generates FPGA configurations. Its biggest difference with the traditional FPGA flow is the use of a new technology mapper, the TLUT mapper. The TLUT tool flow was developed to implement Dynamic Circuit Specialization (DCS) on FPGAs. A DCS implementation of an application specializes its circuit for the current values of a number of specific inputs, called parameters. This specialized circuit is smaller, and in some cases faster, than the original circuit. However, it is only correct for one set of parameter values. Each time the parameters change value, a new specialized circuit is generated. This new specialized circuit is then loaded into the FPGA using partial run-time reconfiguration.\\

The TLUT tool flow offers an efficient implementation of DCS because it uses the concept of parameterized configurations. A parameterized configuration is a configuration in which some bits are expressed as Boolean functions of the parameters. Before the FPGA can be configured, the parameter values are used to evaluate the Boolean functions. This generates the specialized configuration. Several papers on the academic underpinnings of the TLUT tool flow are listed in the wiki of this project or are contained in the documentation directory. There you can also find more information on our current research on extending and improving the TLUT tool flow. The TLUT tool flow itself and how to use it, is described in much more detail in this user guide.

\section{What can I do with this tool flow?}
First, you can evaluate our adapted TLUT technology mapper. 
This  allows you to compare its results with a conventional technology mapper and see for yourself if Dynamic Circuit Specialization can be used to optimize your application. 
We have included a framework to make this comparison very easy. 
The following pages provide clear examples and show how to adapt the framework for you own uses.

Second, our tool flow has been integrated with the Xilinx FPGA tool flow so that you can perform DCS on a commercial Virtex 2 Pro FPGA.
A number of examples that you can run right away on the XUP V2P board are included in this repository. 
Information on creating your own project is also included in this document.
We are currently working on extending this tool flow to more modern FPGAs, such as the Virtex 5 or 6.

\section{Contact us}
The TLUT tool flow is released by Ghent University, ELIS department, Hardware and Embedded Systems (HES) group (\href{http://hes.elis.ugent.be}{\emph{http://hes.elis.ugent.be}}).

If you encounter bugs, want to use the TLUT tool flow but need support or want to tell us about your results, feel free to contact us.
We can be reached at \href{mailto:hes@elis.ugent.be}{\emph{hes@elis.ugent.be}}.

\section{Referencing the TLUT tool flow}
If you use the TLUT tool flow in your work, please reference in your publications the following paper:

\emph{Karel Bruneel, Wim Heirman, and Dirk Stroobandt. 2011. ``Dynamic Data Folding with Parameterizable FPGA Configurations.'' ACM Transactions on Design Automation of Electronic Systems 16 (4).}

You may also refer to one of our others papers if you think it is more related.

\section{Contents of this document}
Chapter~\ref{sec:setup}: \emph{Setup}: A setup manual\\
Chapter~\ref{sec:experiment}: \emph{Your design}: A manual for running your own experiments\\
Chapter~\ref{sec:troubleshooting}: \emph{Troubleshooting}: Problems you may encounter and their solutions\\
Chapter~\ref{sec:contents}: \emph{Contents}: Description of the contents of this package\\
Chapter TODO

\clearpage
\chapter{Setup}\label{sec:setup}
\begin{lstlisting}
> make
\end{lstlisting}
This downloads and builds the dependencies listed below, builds the TLUT technology mapper and creates a `source' file which sets environment variables. 
Make sure you agree with the respective licences of the dependencies before running make. 

Set your environment variables using:
\begin{lstlisting}
> . source
\end{lstlisting}

Your installation can be tested using the script in directory `tests'.
\begin{lstlisting}
> cd tests
> ./examples_test.sh
\end{lstlisting}

Examples can be run using the included Python scripts.
E.g.
\begin{lstlisting}
> cd examples/treeMult4b
> ./treeMult4b.py
\end{lstlisting}

\section{Dependencies}
\begin{itemize}
\item Dependencies to be provided by the user:
\begin{itemize}
\item Quartus II (tested with Web Edition version 11, Web Edition v12 may work but is not supported), Altera Corporation, \url{http://www.altera.com}
\item Java (tested with version 1.6.0), Oracle, \url{http://www.java.com}
\item Python 2.7, \url{http://www.python.org}
\item Xilinx Design Suite 9.1 (tested with version 9.1.02), Xilinx Inc., \url{http://www.xilinx.com}\\
Xilinx Platform Builder is only required for implementation of DCS on a commercial FPGA. Version 9.1 is old, but it is unlikely that other versions will work.
\end{itemize}
\item Dependencies automatically downloaded and installed:
\begin{itemize}
\item Aiger 1.9.4, JKU Institute for Formal Models and Verification, \url{http://fmv.jku.at/aiger}
\item ABC (version 810ba683c042, 5 October 2012), Berkeley Logic Synthesis and Verification Group, \url{http://www.eecs.berkeley.edu/\~alanmi/abc}
\item RapidSmith 0.5.1, BYU RapidSmith Projec,  \url{http://rapidsmith.sourceforge.net}
\item Hessian 4.0.7, Caucho Technology, \url{http://hessian.caucho.com}
\end{itemize}
\end{itemize}

\clearpage
\chapter{Your own design}\label{sec:experiment}
\section{The run function}\label{sec:run_function}
To test the TLUT mapper on your own design (described in VHDL or Verilog), import the \emph{run} function from \emph{fast\_tlutmap} in your own Python script and call it with the following arguments:
\begin{lstlisting}
run(module, submodules, K, performCheck, verboseFlag)
\end{lstlisting}
\begin{itemize}
\item \textbf{module} - String\\
The location of the top level of your design. If your design consists of only one VHDL/Verilog module, then you only have to pass the location of this module as the first argument and you can ignore the second argument.

E.g. run('yourDesign.vhd')

\item \textbf{submodules} - list of Strings - \textit{optional}\\
If your design consists of a top level module and several submodules, you can add a list of submodules here, for example if you have one top level module and two submodules.

E.g. run('yourTopLevelModule.vhd', ['yourFirstSubModule.vhd', 'yourSecondSubModule.vhd'])

\item \textbf{K} - integer - \textit{default 4}\\
You can choose the number of inputs a LookUp Table has on your target FPGA

E.g. run('yourDesign.vhd', 6)
or run('yourDesign.vhd', K=6)

\item \textbf{performCheck} - boolean - \textit{default True}\\
When checks are turned on, the resulting mapping is verified using a miter and satisfiability solver. This ensures that the mapped circuit implements the same functionality as the input circuit.

E.g. run('yourDesign.vhd', 6, True)\\
or run('yourDesign.vhd', performCheck=False)

\item \textbf{verboseFlag} - boolean - \textit{default False}\\
This activates the verbose mode in which more information gets printed regarding the execution of the flow.

E.g. run('yourDesign.vhd', 6, True, True)\\ or run('yourDesign.vhd', verboseFlag=True)
\end{itemize}

\section{A step-by-step approach}\label{sec:step_by_step}
Below, we have provided a more step-by-step approach to set up your own Python script starting from the \emph{treeMult4b} example:
\begin{enumerate}
\item Make a folder for your design and copy the treeMult4b folder from the examples directory. You need at least the files \emph{abc.rc} and \emph{treeMult4b.py}
\begin{lstlisting}
> mkdir yourDesign
> cp -r examples/treeMult4b/* yourDesign/
\end{lstlisting}
\item Replace treeMult4.vhd by copying your VHDL/Verilog files, describing your design, into the \emph{yourDesign}-folder
\begin{lstlisting}
> rm treeMult4b.vhd
\end{lstlisting}
\item Annotate the parameters in your top level VHDL/Verilog file.

Any input signal, or combination of input signals, of your top level module can be chosen as parameter. Preferably the designer will choose the slowly changing input signals as parameters, because a change in the value of the parameters results in a reconfiguration of the FPGA. Different combinations can be tested easily by changing the annotations. In the following example a simple multiplexer is described in VHDL and the `sel' input signal is annotated as a parameter.
\lstset{language=VHDL}
\begin{lstlisting}
entity multiplexer is
port(
  --PARAM
  sel : in  std_logic_vector(1 downto 0);
  --PARAM
  in  : in  std_logic_vector(3 downto 0);
  out : out std_logic
);
end multiplexer;

architecture behavior of multiplexer is
begin
  out <= in(conv_integer(sel));
end behavior;
\end{lstlisting}
The Verilog annotations are quite similar. The following Verilog example, a simple multiplier, can be found in the examples folder;
\lstset{language=Verilog}
\begin{lstlisting}
module mult(x,y,z);
parameter N = 16;
input [N-1:0] x;
//PARAM
input [N-1:0] y;
//PARAM
output [2*N-1:0]z;
assign z = x * y;
endmodule
\end{lstlisting}
 
\item Modify the Python script
\begin{lstlisting}
> mv treeMult4b.py yourDesign.py
> nano yourDesign.py
\end{lstlisting}
Edit the 6th line, in which the \emph{run} function is called, according to the documentation in section~\ref{sec:run_function}.
\item Run the modified Python script
\begin{lstlisting}
> ./yourDesign.py
\end{lstlisting}
\item \label{sec:check_par}Check the `.par' file in the work directory, to ensure the parameters were correctly recognised. It should list all the signal names of the parameters, i.e. one for each line of a bus signal. 
The tool for extracting parameters from VHDL and Verilog is still limited and can not yet parse all VHDL/Verilog constructs.
\item Analyze the results. As an example, the output of the Python script of the treeMult4b project is given;

\begin{lstlisting}
Stage: TLUT mapper
Luts (TLUTs)     depth     check
12.0 (12.0)      1.0       PASSED    
Stage: SimpleMAP
Luts             depth     check     
67.0             10.0      PASSED    
Stage: ABC fpga
Luts             depth     check     
67.0             10.0      PASSED 
\end{lstlisting}

The first column shows the number of LUTs in each mapping solution. These can be compared directly and represents the number of K-LUTs needed to implement the design. In this case, the TLUT mapper needs 12 LUTs, and SimpleMAP and ABC's fpga need 67.

SimpleMAP and ABC fpga both perform mapping for a conventional, not parameterised, configuration. The same results could be expected for both tools because they implement basically the same algorithm. However, ABC fpga contains some optimisations, such as `area recovery', which haven't been (completely) implemented in SimpleMAP. While the number of LUTs may differ between the two tools, you can expect the depth to be always equal.

The number between brackets `()' is only relevant for the TLUT mapper. It shows the number of LUTs that will actually be reconfigured at run-time. We call these LUTs TLUTs. In this case all 12 of the LUTs are TLUTs and will be reconfigured at run-time.

The third column shows the depth of each mapping solution. This is the number of LUTs in the longest path, a measure for the speed of the circuit. 

Finally, column 4 shows if the mapping solution has passed the equivalence test. This check is performed to see if the resulting circuit still has the same functionality as the original input.

% Hier de verschillen tussen simpleMap en abc bespreken of later pas in hoofdstuk 4?

\end{enumerate}

\section{Advanced}
It is also possible to start from an `.aag' or `.blif' file. As a reference for this we provide examples \emph{AES} and \emph{tripleDES}. 
Advanced experiments can be set up by copying \emph{fast\_tlutmap} and using this file as a template for your experiment.

\clearpage
\chapter{Troubleshooting}\label{sec:troubleshooting}
Try running one of the examples (in the examples folder) first. If this works as expected your environment is set up correctly.\\

These are a few common errors and their solution:
\begin{itemize}
\item \emph{Python ImportError: No module named fast\_tlutmap (or others):}\\
The environment variables probably aren't set up correctly. Try running `. source' in the main directory. 
If you have moved the main directory, the paths in the `source' file are not longer correct. Remove this file and recreate it using `make source'.

\item \emph{java.lang.OutOfMemoryError:}\\
The Java technology mappers don't have enough memory available. Try to use the \emph{setMaxMemory} function. It can be imported from the \emph{fast\_tlutmap} Python script and should be called before the \emph{run} function. This function sets the maximum memory usage for the Java tools in megabytes.
\lstset{language=python}
\begin{lstlisting}
from fast_tlutmap import run, setMaxMemory

setMaxMemory(4096)
run('treeMult4b.vhd', K=4, performCheck=True, verboseFlag=False)
\end{lstlisting}

\item \emph{The number of TLUTs is 0, or the reduction in number of LUTs is lower than expected:}\\
Check if all parameters were correctly extracted from your VHDL/Verilog. See section~\ref{sec:step_by_step}, step~\ref{sec:check_par}.
\end{itemize}


\clearpage
\chapter{Xilinx integration}\label{sec:xilinx_flow}
\section{Testing}
A number of example projects are included in this repository that can be run on a XUPV2P board. This section explains how you can run them all to test your setup.

First, connect your XUPV2P board to the computer using a USB cable (for bitstream configuration) and a serial cable (for debugging).
Then, open each of the following projects in XPS and choose ``Generate bitstream''. XPS will produce an error but this is ok.
\begin{itemize}
\item `examples/xorExample/xps'
\item `examples/xorExample/xps\_mi'
\item `examples/treeMult4b/xps'
\end{itemize}
Now you can run all tests on these projects by doing:
\begin{lstlisting}
> cd tests
> ./virtex2pro_test.sh
\end{lstlisting}

Every project is now being built, loaded onto the FPGA and DCS is tested using the embedded PowerPC (you can find the debug output from the FPGA in the `received.txt' file in the project directory). This will take a long time. If everything works fine you will get the following result.
%powerpc-eabi-ar: creating ../../../lib/libxil.a
%powerpc-eabi-ar: creating ../../../lib/libxil.a
%./virtex2pro_test.sh: line 4:  6732 Terminated cat ...
\begin{lstlisting}
...
xorExample/xps succeeded
...
xorExample/xps_mi succeeded
...
treeMult4b/xps succeeded
\end{lstlisting}

Troubleshooting:\\
if stops before printing "failed" message. Compilation failed. Try opening the project in XPS and doing "Generate bitstream" and "Generate all user applications"\\
If received.txt is empty, serial port problem. Try rebooting your computer\\
Check jumpers of XUP2VP board.\\
make sure minicom is not running

\section{Your own project}
This tutorial guides you through the setup and implementation of a design with DCS. You can use it to start your own project or test it with the `xorExample' design.


Voorbereiding(Xilinx):\\
Doorloop stappen 1.1 tot 2.1 van de Hes-wiki (\url{http://hes.elis.ugent.be/wiki/Wiki/%20Dynamic%20reconfiguration/tmap-xps}). Een .proj file is normaal niet nodig.\\
Stap 2.2 doorloop je ook, het toevoegen van de --PARAM annotaties is niet nodig in opb\_xor en user\_logic. (Volgens mij heeft dat geen impact, maar zou nog eens gechecked moeten worden)\\
Pas data/system.ucf aan ...\\
Doe ook stap 3, enkel de testReconfiguration.c file niet downloaden, de dir wel maken.\\
De grootste delen van 4 vallen weg, het enige wat je moet doen is de custom.make klaarzetten zoals in 4.1.\\
Let erop dat je system.make slechts kopieerd naar custom.make nadat je de software applicatie aangemaakt hebt.

De nieuwe stappen zijn dan:\\
a) run generateTMAPMake.py in /design dir.\\
b) voeg "include tmap.make" toe in de custom.make net na "include system\_incl.make"\\
c) Generate bitstream\\
d) add <basename>.c, <basename>.h, locations.h and locations.c to  software project\\
e) create main.c (example code in <basename>.c\\
vanaf nu kan het project volledig gerund worden. De output (printcommands in de c-file) kan gelezen worden in de terminal met het "minicom" command.


Troubleshoot, - source source before running xps

\subsection{Creating a project for the XUPV2P}

\begin{itemize}
\item Start XPS v9. Make sure that you have sourced the ``source'' file from the base directory of this repository in the same terminal as you start XPS in.
\item    Create a new project
\item    Chose the ``Base System Builder wizard''
\item    Chose the project directory
\item    Follow these steps:
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB1}
\caption{Choose to create a new design. Click Next\label{fig:BSB1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB2}
\caption{Choose Xilinx as board vendor. Choose the XUP board. Click Next\label{fig:BSB2}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB3}
\caption{Choose to use a the PowerPc. Click Next\label{fig:BSB3}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB4}
\caption{Choose 50MHz as Bus Clock Frequency (The ICAP can maximally handle 66MHz). Click Next\label{fig:BSB4}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB5}
\caption{Retain only the OPB\_UARTLITE in the next three windows\label{fig:BSB5}}
\end{figure}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.4]{BSB6}
%\caption{\label{fig:BSB6}}
%\end{figure}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.4]{BSB7}
%\caption{\label{fig:BSB7}}
%\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB8}
\caption{Use 64kB of memory. Click Next\label{fig:BSB8}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB9}
\caption{Choose the UART as STDIN and STDOUT. Don't generate sample applications. Click Next\label{fig:BSB9}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB10}
\caption{Generate the project. Click Generate\label{fig:BSB10}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{BSB11}
\caption{Click Finish\label{fig:BSB11}}
\end{figure}


\subsection{Adding the HWICAP}
The HWICAP is used for run-time reconfiguration of the FPGA.
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{HWICAP1}
\caption{In the IP Catalog, double click "OPB FPGA Internal Configuration Access Port". Click Yes\label{fig:HWICAP1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{HWICAP2}
\caption{An instance of the opb\_hwicap appears in the System Assembly View. Connect the hwicap to the opb\label{fig:HWICAP2}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{HWICAP3}
\caption{Open the MHS file by double clicking it in the Project tab. Search the opb\_hwicap instance and change the version from \emph{1.10.a} to \emph{1.00.b}\label{fig:HWICAP3}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{HWICAP4}
\caption{Open the MSS file by double clicking it in the Project tab. Search the opb\_hwicap instance and change the version from \emph{1.01.a} to \emph{1.00.b}\label{fig:HWICAP4}}
\end{figure}

Finally, create a symbolic link in the directory `drivers' (create the directory if needed) of your project to `examples/xorExample/xps/drivers/hwicap\_v1\_00\_b'.

\subsection{Creating a DCS peripheral}
Currently, DCS can only be done on exactly one peripheral of the OPB bus. In this section you create this OPB peripheral with memory mapped registers.
In this section we will build a simple parameterizable module and add it to the base system build in the previous sections. The module has a 32-bit vector, a, as input, a 32-bit vector, x, as output and a one bit parameter, p. If p equals 0 the output vector, x, equals the input vector. If p equals 1 the output vector, x, is the inverse of the input vector, a. Bought the input and the output vector are memory mapped through the OPB. When the parameter, p, changes the PPC will reconfigure the modules TLUTs through the HWICAP.
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP1}
\caption{Start the Create and Import Peripheral Wizard. Start the wizard from the Hardware menu. Click Next\label{fig:COIP1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP2}
\caption{Choose Create templates for a new peripheral. Click Next\label{fig:COIP2}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP3}
\caption{Choose to store the peripheral in the XPS project. Click Next\label{fig:COIP3}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP4}
\caption{Choose a name for the peripheral (E.g. `opb\_xor'). Click Next\label{fig:COIP4}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP5}
\caption{Choose to create an OPB peripheral. Click Next\label{fig:COIP5}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP6}
\caption{Choose for User logic S/W register support deselect S/W reset and MIR. Click Next\label{fig:COIP6}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP7}
\caption{Choose the required number and width of the registers. For the `xorExample' choose two 32-bit registers, one for the input and one for the output. Click Next\label{fig:COIP7}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP8}
\caption{Don't change anything. Click Next\label{fig:COIP8}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP9}
\caption{Don't change anything. Click Next\label{fig:COIP9}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP10}
\caption{Deselect Generate ISE and XPS project files. Click Next\label{fig:COIP10}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{COIP11}
\caption{Click Finish\label{fig:COIP11}}
\end{figure}

\subsection{Adding a DCS peripheral}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{AXOR1}
\caption{In the IP Catalog, double click your OPB peripheral (E.g. `OPB\_XOR'). Click Yes.\label{fig:AXOR1}}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{AXOR2}
\caption{An instance of the peripheral appears in the System Assembly View. Connect the peripheral to the opb\label{fig:AXOR2}}
\end{figure}\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{AXOR3}
\caption{Select the Addresses view in the System Assembly View. Click the Generate Addresses button\label{fig:AXOR3}}
\end{figure}

\clearpage
\chapter{Contents}\label{sec:contents}
The `tlut\_flow' folder contains a number of folders and three files: `Makefile', `README.md' and `LICENSE'. 
The `Makefile' is used to initially set up the tool flow. It will download  some necessary third party tools and compile the used programs.
More information about the license under which the TLUT tool flow is released can be found in `LICENSE'.\\

The `tlut\_flow' folder contains the following folders:  `examples', `tests', `documentation',  `java', `python' and `third\_party'.

\begin{itemize}
\item In the `examples' folder you can find a number of designs that use the TLUT tool flow. You can run each of them by executing the Python script contained in the respective subfolder. You can run all examples at once (except AES) by executing the `run\_all.sh' script.
\item In the `tests' folder you can currently find one test, namely `examples\_test.sh'. Executing this script will run the `examples/run\_all.sh' script and compare the output to the expected output.
\item The `documentation' folder contains this document, and its Latex source files, and the Ph.D. thesis by Karel Bruneel which contains more information about the academic underpinnings of the TLUT tool flow.
\end{itemize}

The remaining folders contain binaries, source code and wrapper scripts. You may want to edit these when doing advanced experiments.
\begin{itemize}
\item The `java' folder contains the Java source and binary files of a simple technology mapper and an adapted parameterized version of this technology mapper, the TLUT technology mapper.
\item After setup, the `third\_party' folder will contain ABC, the logic synthesis and technology mapping tool of the university of Berkeley, and Aiger, a tool used to handle textual (.aag) and binary representations of and-inverter-graphs (.aig).    

\item The `python' folder contains the high level Python scripts that are used to interface with the tools in the other folders. It contains three files: `fast\_tlutmap.py', `genParameters.py' and `mapping.py'. The `genParameters.py' script will extract the parameters from the annotated VHDL file. The `mapping.py' script contains high level wrappers that call the different mappers and a number of utility programs. These 2 last scripts are best used as given. 

The `fast\_tlutmap.py' script contains the main code in the `run' function. This function can easily be adjusted to meet the user's needs. The run function mainly consists of 2 steps: synthesis and technology mapping. The synthesis step converts the VHDL file into a logic circuit in blif format using Quartus II. The technology mapping step will map the logic circuit to a circuit with LUTs. Three different technology mapping tools are included to allow an easy comparison: the simple mapper, the TLUT technology mapper and the ABC mapper. The first two are not as optimized as ABC. For example `area recovery' is not yet completely implemented. The ABC tool flow is an academic framework that does include a large number of such optimizations. Several commercial tools are based on this technology mapper.

The `run' function also contains some intermediate steps:
\begin{itemize} 
\item the conversion of the blif format into the aag format, needed for the Java mappers
\item extraction of the parameters out of the annotated VHDL file
\end{itemize}

\end{itemize}

%Hier zouden ook nog alle voorbeelden moeten beschreven worden, vanaf welke formaat ze starten (vhdl, verilog, aag) en een zin over wat ze moeten voorstellen.



\end{document}
